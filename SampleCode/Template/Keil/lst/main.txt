; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DENABLE_SPI_MASTER --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.CalPeriodTime||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  CalPeriodTime PROC
;;;62     
;;;63     void CalPeriodTime(EPWM_T *EPWM, uint32_t u32Ch)
000000  b57f              PUSH     {r0-r6,lr}
;;;64     {
;;;65         uint16_t u16RisingTime, u16FallingTime, u16HighPeriod, u16LowPeriod, u16TotalPeriod;
;;;66     
;;;67         g_u32CH0TestOver = 0;
000002  4c13              LDR      r4,|L1.80|
000004  2000              MOVS     r0,#0
000006  60a0              STR      r0,[r4,#8]  ; g_u32CH0TestOver
                  |L1.8|
;;;68         /* Wait PDMA interrupt (g_u32CH0TestOver will be set at IRQ_Handler function) */
;;;69         while(g_u32CH0TestOver == 0);
000008  68a0              LDR      r0,[r4,#8]  ; g_u32CH0TestOver
00000a  2800              CMP      r0,#0
00000c  d0fc              BEQ      |L1.8|
;;;70     
;;;71         u16RisingTime = g_u32Count[1];
00000e  4810              LDR      r0,|L1.80|
000010  3010              ADDS     r0,r0,#0x10
000012  8841              LDRH     r1,[r0,#2]  ; g_u32Count
;;;72     
;;;73         u16FallingTime = g_u32Count[0];
000014  8802              LDRH     r2,[r0,#0]  ; g_u32Count
;;;74     
;;;75         u16HighPeriod = g_u32Count[1] - g_u32Count[2] + 1;
000016  8843              LDRH     r3,[r0,#2]  ; g_u32Count
000018  8885              LDRH     r5,[r0,#4]  ; g_u32Count
00001a  1b5b              SUBS     r3,r3,r5
00001c  1c5b              ADDS     r3,r3,#1
;;;76     
;;;77         u16LowPeriod = 0xFFFF - g_u32Count[1];
00001e  8845              LDRH     r5,[r0,#2]  ; g_u32Count
000020  b29b              UXTH     r3,r3                 ;75
000022  f64f76ff          MOV      r6,#0xffff
;;;78     
;;;79         u16TotalPeriod = 0xFFFF - g_u32Count[2] + 1;
000026  8880              LDRH     r0,[r0,#4]  ; g_u32Count
000028  1b75              SUBS     r5,r6,r5              ;77
00002a  4240              RSBS     r0,r0,#0
00002c  b280              UXTH     r0,r0
;;;80     
;;;81         printf("Rising=%5d,Falling=%5d,High=%5d,Low=%5d,Total=%5d,Freq=%5d,Duty=%3d.\r\n",
00002e  68e4              LDR      r4,[r4,#0xc]  ; capt_div_freq
000030  2664              MOVS     r6,#0x64
000032  435e              MULS     r6,r3,r6
000034  fbb6f6f0          UDIV     r6,r6,r0
000038  fbb4f4f0          UDIV     r4,r4,r0
00003c  f10d0c04          ADD      r12,sp,#4
000040  9500              STR      r5,[sp,#0]
000042  e88c0051          STM      r12,{r0,r4,r6}
000046  4803              LDR      r0,|L1.84|
000048  f7fffffe          BL       __2printf
;;;82                u16RisingTime, 
;;;83                u16FallingTime, 
;;;84                u16HighPeriod, 
;;;85                u16LowPeriod, 
;;;86                u16TotalPeriod,
;;;87                capt_div_freq/u16TotalPeriod,
;;;88                u16HighPeriod*100/u16TotalPeriod);
;;;89     }
00004c  bd7f              POP      {r0-r6,pc}
;;;90     
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      ||area_number.23||
                  |L1.84|
                          DCD      ||.conststring||

                          AREA ||i.CalculationPolling||, CODE, READONLY, ALIGN=2

                  CalculationPolling PROC
;;;91     
;;;92     void CalculationPolling(void)
000000  4809              LDR      r0,|L2.40|
;;;93     {
;;;94     	PH1 ^= 1;
000002  6801              LDR      r1,[r0,#0]
000004  f0810101          EOR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;95     	
;;;96         EPWM1->CAPCTL |= EPWM_CAPCTL_FCRLDEN5_Msk;	
00000a  4808              LDR      r0,|L2.44|
00000c  f8d01204          LDR      r1,[r0,#0x204]
000010  f0415100          ORR      r1,r1,#0x20000000
000014  f8c01204          STR      r1,[r0,#0x204]
                  |L2.24|
;;;97     	
;;;98         while((EPWM1->CNT[EPWM_CAPx]) == 0);
000018  f8d010a4          LDR      r1,[r0,#0xa4]
00001c  2900              CMP      r1,#0
00001e  d0fb              BEQ      |L2.24|
;;;99     
;;;100        /* Capture the Input Waveform Data */
;;;101        CalPeriodTime(EPWM1, EPWM_CAPx);
000020  2105              MOVS     r1,#5
000022  f7ffbffe          B.W      CalPeriodTime
;;;102    	
;;;103    }
;;;104    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x400049c4
                  |L2.44|
                          DCD      0x40059000

                          AREA ||i.EPWM_CAP_Disable||, CODE, READONLY, ALIGN=2

                  EPWM_CAP_Disable PROC
;;;104    
;;;105    void EPWM_CAP_Disable(void)
000000  b510              PUSH     {r4,lr}
;;;106    {
;;;107        EPWM_Stop(EPWM1, EPWM_CH_5_MASK);
000002  4c12              LDR      r4,|L3.76|
000004  2120              MOVS     r1,#0x20
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       EPWM_Stop
                  |L3.12|
;;;108    
;;;109        /* Wait until EPWM1 channel 2 current counter reach to 0 */
;;;110        while((EPWM1->CNT[EPWM_CAPx] & EPWM_CNT5_CNT_Msk) != 0);
00000c  f8d410a4          LDR      r1,[r4,#0xa4]
000010  0409              LSLS     r1,r1,#16
000012  0c09              LSRS     r1,r1,#16
000014  d1fa              BNE      |L3.12|
;;;111    
;;;112        EPWM_ForceStop(EPWM1, EPWM_CH_5_MASK);
000016  2120              MOVS     r1,#0x20
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       EPWM_ForceStop
;;;113    
;;;114        EPWM_DisableCapture(EPWM1, EPWM_CH_5_MASK);
00001e  2120              MOVS     r1,#0x20
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       EPWM_DisableCapture
;;;115    
;;;116        EPWM_ClearCaptureIntFlag(EPWM1, EPWM_CAPx, EPWM_CAPTURE_PDMA_RISING_FALLING_LATCH);
000026  2206              MOVS     r2,#6
000028  2105              MOVS     r1,#5
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       EPWM_ClearCaptureIntFlag
;;;117    
;;;118    	EPWM_DisablePDMA(EPWM1, EPWM_CAPx);
000030  2105              MOVS     r1,#5
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       EPWM_DisablePDMA
000038  4905              LDR      r1,|L3.80|
00003a  f44f7080          MOV      r0,#0x100
00003e  f8c10180          STR      r0,[r1,#0x180]
;;;119    
;;;120        NVIC_DisableIRQ(PDMA_IRQn);
;;;121    
;;;122        PDMA_Close(PDMA);
000042  e8bd4010          POP      {r4,lr}
000046  4803              LDR      r0,|L3.84|
000048  f7ffbffe          B.W      PDMA_Close
;;;123    	
;;;124    }
;;;125    
                          ENDP

                  |L3.76|
                          DCD      0x40059000
                  |L3.80|
                          DCD      0xe000e004
                  |L3.84|
                          DCD      0x40008000

                          AREA ||i.EPWM_CAP_Init||, CODE, READONLY, ALIGN=2

                  EPWM_CAP_Init PROC
;;;145    
;;;146    void EPWM_CAP_Init(void)	
000000  b510              PUSH     {r4,lr}
;;;147    {
;;;148    	uint32_t target_ns = 0;
;;;149    		
;;;150    	/*
;;;151    			use PLL : 192000000
;;;152    			use PCLK1 : depend on div. , exmaple : div = 2 , capture clock = 192000000/2 = 96000000
;;;153    	
;;;154               (CNR+1) = Capture clock source frequency/prescaler/minimum input frequency
;;;155    
;;;156               how to get PSC , make CNR+1 close to 0xFFFF , 
;;;157               target freq = 15  
;;;158               ==> CNR+1 = 192000000 / PSC / min_freq , when CNR = 65535 with freq = 15 , will get PSC 293
;;;159    
;;;160               Capture unit time = 1/Capture clock source frequency/prescaler
;;;161               ==> target ns = 1/ 192000000 / 293 = 293/ 19200000 = 1526 ns
;;;162    
;;;163    	*/
;;;164    	capt_psc = 293;
000002  490d              LDR      r1,|L4.56|
000004  f2401025          MOV      r0,#0x125
;;;165    	target_ns = 1526;
;;;166    	capt_div_freq = FREQ_192MHZ/capt_psc;
000008  4b0c              LDR      r3,|L4.60|
00000a  8048              STRH     r0,[r1,#2]            ;164
00000c  fbb3f0f0          UDIV     r0,r3,r0
;;;167    
;;;168        EPWM_ConfigCaptureChannel(EPWM1, EPWM_CAPx, target_ns, 0);	//target_ns
000010  60c8              STR      r0,[r1,#0xc]  ; capt_div_freq
000012  4c0b              LDR      r4,|L4.64|
000014  f24052f6          MOV      r2,#0x5f6             ;165
000018  2300              MOVS     r3,#0
00001a  2105              MOVS     r1,#5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       EPWM_ConfigCaptureChannel
;;;169    
;;;170        EPWM_Start(EPWM1, EPWM_CH_5_MASK);
000022  2120              MOVS     r1,#0x20
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       EPWM_Start
;;;171    
;;;172        EPWM_EnableCapture(EPWM1, EPWM_CH_5_MASK);
00002a  4620              MOV      r0,r4
00002c  e8bd4010          POP      {r4,lr}
000030  2120              MOVS     r1,#0x20
000032  f7ffbffe          B.W      EPWM_EnableCapture
;;;173    
;;;174    //    EPWM1->CAPCTL |= EPWM_CAPCTL_FCRLDEN5_Msk;
;;;175    
;;;176    //    while((EPWM1->CNT[EPWM_CAPx]) == 0);
;;;177    
;;;178    //    CalPeriodTime(EPWM1, EPWM_CAPx);
;;;179    }
;;;180    
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
                          DCD      ||area_number.23||
                  |L4.60|
                          DCD      0x0b71b000
                  |L4.64|
                          DCD      0x40059000

                          AREA ||i.EPWM_CAP_PDMA_Init||, CODE, READONLY, ALIGN=2

                  EPWM_CAP_PDMA_Init PROC
;;;125    
;;;126    void EPWM_CAP_PDMA_Init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;127    {
;;;128    
;;;129        PDMA_Open(PDMA,BIT0);
000002  4d1a              LDR      r5,|L5.108|
000004  2101              MOVS     r1,#1
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       PDMA_Open
;;;130    
;;;131        PDMA_SetTransferCnt(PDMA,PDMA_CHx, PDMA_WIDTH_16, 4);
00000c  2304              MOVS     r3,#4
00000e  029a              LSLS     r2,r3,#10
000010  2100              MOVS     r1,#0
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       PDMA_SetTransferCnt
;;;132    
;;;133        PDMA_SetTransferAddr(PDMA,PDMA_CHx, (uint32_t)&(EPWM1->PDMACAP[2]), PDMA_SAR_FIX, (uint32_t)&g_u32Count[0], PDMA_DAR_INC);
000018  2400              MOVS     r4,#0
00001a  4915              LDR      r1,|L5.112|
00001c  e9cd1400          STRD     r1,r4,[sp,#0]
000020  f44f7340          MOV      r3,#0x300
000024  4a13              LDR      r2,|L5.116|
000026  4621              MOV      r1,r4
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       PDMA_SetTransferAddr
;;;134    
;;;135        PDMA_SetTransferMode(PDMA,PDMA_CHx, PDMA_EPWM1_P3_RX, FALSE, 0);
00002e  2300              MOVS     r3,#0
000030  2225              MOVS     r2,#0x25
000032  4619              MOV      r1,r3
000034  4628              MOV      r0,r5
000036  9400              STR      r4,[sp,#0]
000038  f7fffffe          BL       PDMA_SetTransferMode
;;;136    
;;;137        PDMA_SetBurstType(PDMA,PDMA_CHx, PDMA_REQ_SINGLE, PDMA_BURST_4);
00003c  2350              MOVS     r3,#0x50
00003e  2204              MOVS     r2,#4
000040  2100              MOVS     r1,#0
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       PDMA_SetBurstType
;;;138    
;;;139        PDMA_EnableInt(PDMA,PDMA_CHx, PDMA_INT_TRANS_DONE);
000048  2200              MOVS     r2,#0
00004a  4611              MOV      r1,r2
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       PDMA_EnableInt
;;;140    	
;;;141        NVIC_EnableIRQ(PDMA_IRQn);
000052  2028              MOVS     r0,#0x28
000054  f7fffffe          BL       NVIC_EnableIRQ
;;;142    
;;;143        EPWM_EnablePDMA(EPWM1, EPWM_CAPx, FALSE, EPWM_CAPTURE_PDMA_RISING_FALLING_LATCH);
000058  b002              ADD      sp,sp,#8
00005a  2306              MOVS     r3,#6
00005c  e8bd4070          POP      {r4-r6,lr}
000060  2200              MOVS     r2,#0
000062  2105              MOVS     r1,#5
000064  4804              LDR      r0,|L5.120|
000066  f7ffbffe          B.W      EPWM_EnablePDMA
;;;144    }
;;;145    
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      0x40008000
                  |L5.112|
                          DCD      ||area_number.23||+0x10
                  |L5.116|
                          DCD      0x40059248
                  |L5.120|
                          DCD      0x40059000

                          AREA ||i.EPWM_DeInit||, CODE, READONLY, ALIGN=2

                  EPWM_DeInit PROC
;;;209    
;;;210    void EPWM_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;211    {
;;;212        /* Set PWM0 channel 0 loaded value as 0 */
;;;213        EPWM_Stop(EPWM0, EPWM_CH_2_MASK);
000002  4c07              LDR      r4,|L6.32|
000004  2104              MOVS     r1,#4
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       EPWM_Stop
;;;214    
;;;215        /* Wait until PWM0 channel 0 Timer Stop */
;;;216    //    while((PWM0->CNT[0] & PWM_CNT_CNT_Msk) != 0);
;;;217    
;;;218        /* Disable Timer for PWM0 channel 0 */
;;;219        EPWM_ForceStop(EPWM0, EPWM_CH_2_MASK);
00000c  2104              MOVS     r1,#4
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EPWM_ForceStop
;;;220    
;;;221        /* Disable PWM Output path for PWM0 channel 0 */
;;;222        EPWM_DisableOutput(EPWM0, EPWM_CH_2_MASK);
000014  4620              MOV      r0,r4
000016  e8bd4010          POP      {r4,lr}
00001a  2104              MOVS     r1,#4
00001c  f7ffbffe          B.W      EPWM_DisableOutput
;;;223    }
;;;224    
                          ENDP

                  |L6.32|
                          DCD      0x40058000

                          AREA ||i.EPWM_Init||, CODE, READONLY, ALIGN=2

                  EPWM_Init PROC
;;;224    
;;;225    void EPWM_Init(void)	//PA3
000000  b510              PUSH     {r4,lr}
;;;226    {
;;;227        EPWM_ConfigOutputChannel(EPWM0, 2, pwm_freq, pwm_duty);
000002  4809              LDR      r0,|L7.40|
000004  4c09              LDR      r4,|L7.44|
000006  220f              MOVS     r2,#0xf
000008  7803              LDRB     r3,[r0,#0]  ; pwm_duty
00000a  2102              MOVS     r1,#2
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       EPWM_ConfigOutputChannel
;;;228    
;;;229        EPWM_EnableOutput(EPWM0, EPWM_CH_2_MASK);
000012  2104              MOVS     r1,#4
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       EPWM_EnableOutput
;;;230    
;;;231        /* Start EPWM0 counter */
;;;232        EPWM_Start(EPWM0, EPWM_CH_2_MASK);
00001a  4620              MOV      r0,r4
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      EPWM_Start
;;;233    }
;;;234    
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      ||area_number.23||
                  |L7.44|
                          DCD      0x40058000

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;181    
;;;182    void PDMA_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;183    {
;;;184        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  4811              LDR      r0,|L9.72|
000004  6800              LDR      r0,[r0,#0]
;;;185    
;;;186        if(status & PDMA_INTSTS_ABTIF_Msk)    /* abort */
;;;187        {
;;;188            if(PDMA_GET_ABORT_STS(PDMA) & PDMA_ABTSTS_ABTIF0_Msk)
;;;189                g_u32CH0TestOver = 2;
000006  4911              LDR      r1,|L9.76|
000008  07c2              LSLS     r2,r0,#31             ;186
;;;190            PDMA_CLR_ABORT_FLAG(PDMA,PDMA_ABTSTS_ABTIF0_Msk);
00000a  f04f0401          MOV      r4,#1
00000e  d008              BEQ      |L9.34|
000010  480d              LDR      r0,|L9.72|
000012  1d00              ADDS     r0,r0,#4              ;188
000014  6802              LDR      r2,[r0,#0]            ;188
000016  07d2              LSLS     r2,r2,#31             ;188
000018  d001              BEQ      |L9.30|
00001a  2202              MOVS     r2,#2                 ;189
00001c  608a              STR      r2,[r1,#8]            ;189  ; g_u32CH0TestOver
                  |L9.30|
00001e  6004              STR      r4,[r0,#0]
;;;191        }
;;;192        else if(status & PDMA_INTSTS_TDIF_Msk)      /* done */
;;;193        {
;;;194            if(PDMA_GET_TD_STS(PDMA) & PDMA_TDSTS_TDIF0_Msk)
;;;195            {		
;;;196    			g_u32CH0TestOver = 1;
;;;197    			
;;;198    //			EPWM_CAP_Disable();
;;;199    			EPWM_CAP_PDMA_Init();
;;;200    			EPWM_CAP_Init();
;;;201            }
;;;202    		PDMA_CLR_TD_FLAG(PDMA,PDMA_TDSTS_TDIF0_Msk);	
;;;203    		
;;;204        }
;;;205        else
;;;206            printf("unknown interrupt !!\n");
;;;207    }
000020  bd70              POP      {r4-r6,pc}
                  |L9.34|
000022  0780              LSLS     r0,r0,#30             ;192
000024  d50b              BPL      |L9.62|
000026  4d08              LDR      r5,|L9.72|
000028  3508              ADDS     r5,r5,#8              ;194
00002a  6828              LDR      r0,[r5,#0]            ;194
00002c  07c0              LSLS     r0,r0,#31             ;194
00002e  d004              BEQ      |L9.58|
000030  608c              STR      r4,[r1,#8]            ;196  ; g_u32CH0TestOver
000032  f7fffffe          BL       EPWM_CAP_PDMA_Init
000036  f7fffffe          BL       EPWM_CAP_Init
                  |L9.58|
00003a  602c              STR      r4,[r5,#0]            ;202
00003c  bd70              POP      {r4-r6,pc}
                  |L9.62|
00003e  e8bd4070          POP      {r4-r6,lr}            ;206
000042  a003              ADR      r0,|L9.80|
000044  f7ffbffe          B.W      __2printf
;;;208    
                          ENDP

                  |L9.72|
                          DCD      0x4000841c
                  |L9.76|
                          DCD      ||area_number.23||
                  |L9.80|
000050  756e6b6e          DCB      "unknown interrupt !!\n",0
000054  6f776e20
000058  696e7465
00005c  72727570
000060  74202121
000064  0a00    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;389    
;;;390    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L10.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L10.10|
;;;391    {
;;;392        /*---------------------------------------------------------------------------------------------------------*/
;;;393        /* Init System Clock                                                                                       */
;;;394        /*---------------------------------------------------------------------------------------------------------*/
;;;395        /* Unlock protected registers */
;;;396        SYS_UnlockReg();
;;;397    
;;;398        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;399        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2040          MOV      r0,#0x40004000
000022  f8d01140          LDR      r1,[r0,#0x140]
000026  f02101f0          BIC      r1,r1,#0xf0
00002a  f8c01140          STR      r1,[r0,#0x140]
;;;400    
;;;401        /* Enable External XTAL (4~24 MHz) */
;;;402        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;403    
;;;404        /* Waiting for 12MHz clock ready */
;;;405        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;406    
;;;407        /* Set core clock as PLL_CLOCK from PLL */
;;;408        CLK_SetCoreClock(FREQ_192MHZ);
00003a  4825              LDR      r0,|L10.208|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;409        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;410        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;411    
;;;412        /* Enable UART clock */
;;;413        CLK_EnableModuleClock(UART0_MODULE);
000046  4d23              LDR      r5,|L10.212|
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;414    
;;;415        /* Select UART clock source from HXT */
;;;416        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       CLK_SetModuleClock
;;;417    
;;;418        /* Enable PDMA module clock */
;;;419        CLK_EnableModuleClock(PDMA_MODULE);
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       CLK_EnableModuleClock
;;;420    
;;;421        CLK_EnableModuleClock(TMR1_MODULE);
00005e  4d1e              LDR      r5,|L10.216|
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       CLK_EnableModuleClock
;;;422        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
000066  2200              MOVS     r2,#0
000068  f44f41e0          MOV      r1,#0x7000
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       CLK_SetModuleClock
;;;423    
;;;424        /* Enable IP module clock */
;;;425        CLK_EnableModuleClock(EPWM0_MODULE);
000072  4d1a              LDR      r5,|L10.220|
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       CLK_EnableModuleClock
;;;426    
;;;427        /* EPWM clock frequency is set double to PCLK: select EPWM module clock source as PLL */
;;;428        CLK_SetModuleClock(EPWM0_MODULE, CLK_CLKSEL2_EPWM0SEL_PLL, (uint32_t)NULL);
00007a  2200              MOVS     r2,#0
00007c  4611              MOV      r1,r2
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       CLK_SetModuleClock
;;;429    
;;;430        SYS->GPA_MFPL = (SYS->GPA_MFPL & ~SYS_GPA_MFPL_PA3MFP_Msk) | SYS_GPA_MFPL_PA3MFP_EPWM0_CH2;	
000084  6b20              LDR      r0,[r4,#0x30]
000086  f4204070          BIC      r0,r0,#0xf000
00008a  f4404050          ORR      r0,r0,#0xd000
00008e  6320              STR      r0,[r4,#0x30]
;;;431    
;;;432        /* Enable IP module clock */
;;;433        CLK_EnableModuleClock(EPWM1_MODULE);
000090  4d13              LDR      r5,|L10.224|
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       CLK_EnableModuleClock
;;;434    
;;;435        CLK_SetModuleClock(EPWM1_MODULE, CLK_CLKSEL2_EPWM1SEL_PLL, (uint32_t)NULL);
000098  2200              MOVS     r2,#0
00009a  4611              MOV      r1,r2
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       CLK_SetModuleClock
;;;436    
;;;437        SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB6MFP_Msk );
0000a2  6ba0              LDR      r0,[r4,#0x38]
0000a4  f0206070          BIC      r0,r0,#0xf000000
0000a8  63a0              STR      r0,[r4,#0x38]
;;;438        SYS->GPB_MFPL |= (SYS_GPB_MFPL_PB6MFP_EPWM1_CH5 );	
0000aa  6ba0              LDR      r0,[r4,#0x38]
0000ac  f0406040          ORR      r0,r0,#0xc000000
0000b0  63a0              STR      r0,[r4,#0x38]
;;;439    	
;;;440        /* Update System Core Clock */
;;;441        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;442        SystemCoreClockUpdate();
0000b2  f7fffffe          BL       SystemCoreClockUpdate
;;;443    
;;;444        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;445        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
0000b6  6be0              LDR      r0,[r4,#0x3c]
0000b8  f420007f          BIC      r0,r0,#0xff0000
0000bc  63e0              STR      r0,[r4,#0x3c]
;;;446        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
0000be  6be0              LDR      r0,[r4,#0x3c]
0000c0  f44000cc          ORR      r0,r0,#0x660000
0000c4  63e0              STR      r0,[r4,#0x3c]
0000c6  2000              MOVS     r0,#0
0000c8  f8c40100          STR      r0,[r4,#0x100]
;;;447    	
;;;448        /* Lock protected registers */
;;;449        SYS_LockReg();
;;;450    }
0000cc  bd70              POP      {r4-r6,pc}
;;;451    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L10.208|
                          DCD      0x0b71b000
                  |L10.212|
                          DCD      0x57803d10
                  |L10.216|
                          DCD      0x5ec00003
                  |L10.220|
                          DCD      0xa2000010
                  |L10.224|
                          DCD      0xa2100011

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;256    
;;;257    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;258    {
;;;259    	GPIO_SetMode(PH, BIT0, GPIO_MODE_OUTPUT);	//monitor
000002  4c0f              LDR      r4,|L11.64|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;260    	GPIO_SetMode(PH, BIT1, GPIO_MODE_OUTPUT);	//monitor
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;261    	
;;;262        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000018  4c0a              LDR      r4,|L11.68|
00001a  f44f727a          MOV      r2,#0x3e8
00001e  f04f6100          MOV      r1,#0x8000000
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       TIMER_Open
000028  6820              LDR      r0,[r4,#0]
00002a  f0405000          ORR      r0,r0,#0x20000000
00002e  6020              STR      r0,[r4,#0]
;;;263        TIMER_EnableInt(TIMER1);
;;;264        NVIC_EnableIRQ(TMR1_IRQn);	
000030  2021              MOVS     r0,#0x21
000032  f7fffffe          BL       NVIC_EnableIRQ
000036  6820              LDR      r0,[r4,#0]
000038  f0404080          ORR      r0,r0,#0x40000000
00003c  6020              STR      r0,[r4,#0]
;;;265        TIMER_Start(TIMER1);
;;;266    }
00003e  bd10              POP      {r4,pc}
;;;267    
                          ENDP

                  |L11.64|
                          DCD      0x400041c0
                  |L11.68|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;236    
;;;237    void TMR1_IRQHandler(void)
000000  480b              LDR      r0,|L12.48|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;238    {
000008  2900              CMP      r1,#0
00000a  d00f              BEQ      |L12.44|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;239    	static uint16_t CNT = 0;	
;;;240    //	static uint32_t log = 0;	
;;;241    	
;;;242        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;243        {
;;;244            TIMER_ClearIntFlag(TIMER1);
;;;245    	
;;;246    		if (CNT++ > 1000)
000010  4908              LDR      r1,|L12.52|
000012  8888              LDRH     r0,[r1,#4]  ; CNT
000014  1c42              ADDS     r2,r0,#1
000016  808a              STRH     r2,[r1,#4]
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d906              BLS      |L12.44|
;;;247    		{		
;;;248    			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  8088              STRH     r0,[r1,#4]
;;;249    			PH0 ^= 1;
000022  4805              LDR      r0,|L12.56|
000024  6801              LDR      r1,[r0,#0]
000026  f0810101          EOR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
                  |L12.44|
;;;250    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;251    
;;;252    		}
;;;253    		
;;;254        }
;;;255    }
00002c  4770              BX       lr
;;;256    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x40050100
                  |L12.52|
                          DCD      ||area_number.23||
                  |L12.56|
                          DCD      0x400049c0

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  UART0_IRQHandler PROC
;;;293    
;;;294    void UART0_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
;;;296    	uint8_t i;
;;;297    	static uint16_t u16UART_RX_Buffer_Index = 0;
;;;298    
;;;299        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk))    
000002  4d22              LDR      r5,|L13.140|
000004  69e8              LDR      r0,[r5,#0x1c]
;;;300        {
;;;301            /* UART receive data available flag */
;;;302            
;;;303            /* Record RDA interrupt trigger times */
;;;304            uart0Dev.RDA_Trigger_Cnt++;
000006  4c22              LDR      r4,|L13.144|
;;;305            
;;;306            /* Move the data from Rx FIFO to sw buffer (RAM). */
;;;307            /* Every time leave 1 byte data in FIFO for Rx timeout */
;;;308            for(i = 0 ; i < (FIFO_THRESHOLD - 1) ; i++)
;;;309            {
;;;310                uart0Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
000008  4a22              LDR      r2,|L13.148|
00000a  05c0              LSLS     r0,r0,#23             ;299
00000c  f04f0300          MOV      r3,#0                 ;299
000010  d513              BPL      |L13.58|
000012  f8940102          LDRB     r0,[r4,#0x102]        ;304  ; uart0Dev
000016  1c40              ADDS     r0,r0,#1              ;304
000018  f8840102          STRB     r0,[r4,#0x102]        ;304
00001c  2100              MOVS     r1,#0                 ;308
                  |L13.30|
00001e  682e              LDR      r6,[r5,#0]
000020  88d0              LDRH     r0,[r2,#6]  ; u16UART_RX_Buffer_Index
000022  5426              STRB     r6,[r4,r0]
000024  1c40              ADDS     r0,r0,#1
;;;311                u16UART_RX_Buffer_Index ++;
000026  b280              UXTH     r0,r0
000028  80d0              STRH     r0,[r2,#6]
;;;312    
;;;313                if (u16UART_RX_Buffer_Index >= RX_BUFFER_SIZE) 
00002a  28ff              CMP      r0,#0xff
00002c  d900              BLS      |L13.48|
;;;314                    u16UART_RX_Buffer_Index = 0;
00002e  80d3              STRH     r3,[r2,#6]
                  |L13.48|
000030  1c49              ADDS     r1,r1,#1
000032  b2c9              UXTB     r1,r1                 ;308
000034  2903              CMP      r1,#3                 ;308
000036  d3f2              BCC      |L13.30|
                  |L13.56|
;;;315            }
;;;316        }
;;;317        else if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RXTOINT_Msk)) 
;;;318        {
;;;319            /* When Rx timeout flag is set to 1, it means there is no data needs to be transmitted. */
;;;320    
;;;321            /* Record Timeout times */
;;;322            uart0Dev.RXTO_Trigger_Cnt++;
;;;323    
;;;324            /* Move the last data from Rx FIFO to sw buffer. */
;;;325            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;326            {
;;;327                uart0Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
;;;328                u16UART_RX_Buffer_Index ++;
;;;329            }
;;;330    
;;;331            /* Clear UART RX parameter */
;;;332            UART_DISABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;333            u16UART_RX_Buffer_Index = 0;
;;;334    
;;;335    //		set_flag(flag_UART0_Received_Data , ENABLE);
;;;336    
;;;337    		#if 1
;;;338    		printf("UART RX : 0x%2X \r\n" , uart0Dev.RX_Buffer[0]);
;;;339    		
;;;340    		UART0_Process(uart0Dev.RX_Buffer[0]);
;;;341    		#else
;;;342    
;;;343            printf("\nUART0 Rx Received Data : %s\n",uart0Dev.RX_Buffer);
;;;344            printf("UART0 Rx RDA (Fifofull) interrupt times : %d\n",uart0Dev.RDA_Trigger_Cnt);
;;;345            printf("UART0 Rx RXTO (Timeout) interrupt times : %d\n",uart0Dev.RXTO_Trigger_Cnt);
;;;346    		#endif
;;;347    
;;;348            /* Reset UART interrupt parameter */
;;;349            UART_EnableInt(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;350    		memset(&uart0Dev, 0x00, sizeof(UART_BUF_t));
;;;351    
;;;352        }
;;;353    	
;;;354    }
000038  bd70              POP      {r4-r6,pc}
                  |L13.58|
00003a  69e8              LDR      r0,[r5,#0x1c]         ;317
00003c  04c0              LSLS     r0,r0,#19             ;317
00003e  d5fb              BPL      |L13.56|
000040  f8940103          LDRB     r0,[r4,#0x103]        ;322  ; uart0Dev
000044  1c40              ADDS     r0,r0,#1              ;322
000046  f8840103          STRB     r0,[r4,#0x103]        ;322
00004a  e004              B        |L13.86|
                  |L13.76|
00004c  6828              LDR      r0,[r5,#0]            ;327
00004e  88d1              LDRH     r1,[r2,#6]            ;327  ; u16UART_RX_Buffer_Index
000050  5460              STRB     r0,[r4,r1]            ;327
000052  1c49              ADDS     r1,r1,#1              ;327
000054  80d1              STRH     r1,[r2,#6]            ;328
                  |L13.86|
000056  69a8              LDR      r0,[r5,#0x18]         ;325
000058  0440              LSLS     r0,r0,#17             ;325
00005a  d5f7              BPL      |L13.76|
00005c  6868              LDR      r0,[r5,#4]            ;332
00005e  f0200011          BIC      r0,r0,#0x11           ;332
000062  6068              STR      r0,[r5,#4]            ;332
000064  80d3              STRH     r3,[r2,#6]            ;333
000066  7821              LDRB     r1,[r4,#0]            ;338  ; uart0Dev
000068  a00b              ADR      r0,|L13.152|
00006a  f7fffffe          BL       __2printf
00006e  7820              LDRB     r0,[r4,#0]            ;340  ; uart0Dev
000070  f7fffffe          BL       UART0_Process
000074  2111              MOVS     r1,#0x11              ;349
000076  4628              MOV      r0,r5                 ;349
000078  f7fffffe          BL       UART_EnableInt
00007c  e8bd4070          POP      {r4-r6,lr}            ;350
000080  f44f7182          MOV      r1,#0x104             ;350
000084  4802              LDR      r0,|L13.144|
000086  f7ffbffe          B.W      __aeabi_memclr
;;;355    
                          ENDP

00008a  0000              DCW      0x0000
                  |L13.140|
                          DCD      0x40070000
                  |L13.144|
                          DCD      ||.bss||
                  |L13.148|
                          DCD      ||area_number.23||
                  |L13.152|
000098  55415254          DCB      "UART RX : 0x%2X \r\n",0
00009c  20525820
0000a0  3a203078
0000a4  25325820
0000a8  0d0a00  
0000ab  00                DCB      0

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;355    
;;;356    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;357    {
;;;358        SYS_ResetModule(UART0_RST);
000002  4822              LDR      r0,|L14.140|
000004  f7fffffe          BL       SYS_ResetModule
;;;359    
;;;360        /* Configure UART0 and set UART0 baud rate */
;;;361        UART_Open(UART0, 115200);
000008  4c21              LDR      r4,|L14.144|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;362    
;;;363    	/* Set UART receive time-out */
;;;364    	UART_SetTimeoutCnt(UART0, RX_TIMEOUT_CNT);
000014  213c              MOVS     r1,#0x3c
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;365    
;;;366    	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;367        UART0->FIFO = ((UART0->FIFO & (~UART_FIFO_RFITL_Msk)) | UART_FIFO_RFITL_4BYTES);
00001c  68a0              LDR      r0,[r4,#8]
00001e  f02000f0          BIC      r0,r0,#0xf0
000022  f0400010          ORR      r0,r0,#0x10
000026  60a0              STR      r0,[r4,#8]
;;;368    
;;;369    	/* Enable UART Interrupt - */
;;;370    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
000028  6860              LDR      r0,[r4,#4]
00002a  f6400111          MOV      r1,#0x811
00002e  4308              ORRS     r0,r0,r1
000030  6060              STR      r0,[r4,#4]
;;;371    	
;;;372    	NVIC_EnableIRQ(UART0_IRQn);
000032  2024              MOVS     r0,#0x24
000034  f7fffffe          BL       NVIC_EnableIRQ
;;;373    	
;;;374    	memset(&uart0Dev, 0x00, sizeof(UART_BUF_t));
000038  f44f7182          MOV      r1,#0x104
00003c  4815              LDR      r0,|L14.148|
00003e  f7fffffe          BL       __aeabi_memclr
                  |L14.66|
;;;375    
;;;376    	UART_WAIT_TX_EMPTY(UART0);
000042  69a0              LDR      r0,[r4,#0x18]
000044  00c0              LSLS     r0,r0,#3
000046  d5fc              BPL      |L14.66|
;;;377    	
;;;378    //	set_flag(flag_UART0_Received_Data , DISABLE);
;;;379    
;;;380    	printf("CLK_GetModuleClockSource : %8d\r\n",CLK_GetModuleClockSource(EPWM1_MODULE));
000048  4813              LDR      r0,|L14.152|
00004a  f7fffffe          BL       CLK_GetModuleClockSource
00004e  4601              MOV      r1,r0
000050  a012              ADR      r0,|L14.156|
000052  f7fffffe          BL       __2printf
;;;381    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000056  f7fffffe          BL       CLK_GetCPUFreq
00005a  4601              MOV      r1,r0
00005c  a018              ADR      r0,|L14.192|
00005e  f7fffffe          BL       __2printf
;;;382    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());	
000062  f7fffffe          BL       CLK_GetHCLKFreq
000066  4601              MOV      r1,r0
000068  a01c              ADR      r0,|L14.220|
00006a  f7fffffe          BL       __2printf
;;;383    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00006e  f7fffffe          BL       CLK_GetPCLK0Freq
000072  4601              MOV      r1,r0
000074  a01f              ADR      r0,|L14.244|
000076  f7fffffe          BL       __2printf
;;;384    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00007a  f7fffffe          BL       CLK_GetPCLK1Freq
00007e  4601              MOV      r1,r0
000080  e8bd4010          POP      {r4,lr}
000084  a022              ADR      r0,|L14.272|
000086  f7ffbffe          B.W      __2printf
;;;385    
;;;386    	
;;;387    
;;;388    }
;;;389    
                          ENDP

00008a  0000              DCW      0x0000
                  |L14.140|
                          DCD      0x04000010
                  |L14.144|
                          DCD      0x40070000
                  |L14.148|
                          DCD      ||.bss||
                  |L14.152|
                          DCD      0xa2100011
                  |L14.156|
00009c  434c4b5f          DCB      "CLK_GetModuleClockSource : %8d\r\n",0
0000a0  4765744d
0000a4  6f64756c
0000a8  65436c6f
0000ac  636b536f
0000b0  75726365
0000b4  203a2025
0000b8  38640d0a
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L14.192|
0000c0  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
0000c4  4b5f4765
0000c8  74435055
0000cc  46726571
0000d0  203a2025
0000d4  38640d0a
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L14.220|
0000dc  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
0000e0  47657448
0000e4  434c4b46
0000e8  72657120
0000ec  3a202538
0000f0  640d0a00
                  |L14.244|
0000f4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000f8  47657450
0000fc  434c4b30
000100  46726571
000104  203a2025
000108  38640d0a
00010c  00      
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0
                  |L14.272|
000110  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
000114  47657450
000118  434c4b31
00011c  46726571
000120  203a2025
000124  38640d0a
000128  00      
000129  00                DCB      0
00012a  00                DCB      0
00012b  00                DCB      0

                          AREA ||i.UART0_Process||, CODE, READONLY, ALIGN=2

                  UART0_Process PROC
;;;268    
;;;269    void UART0_Process(uint8_t rx)
000000  b430              PUSH     {r4,r5}
;;;270    {
;;;271    	switch(rx)
;;;272    	{
;;;273    		case '1':				
;;;274    			pwm_duty = ( pwm_duty > 90) ? (90) : (pwm_duty+1) ;
000002  4a17              LDR      r2,|L15.96|
;;;275        		EPWM_ConfigOutputChannel(EPWM0, 2, pwm_freq, pwm_duty);			
000004  4c15              LDR      r4,|L15.92|
000006  2831              CMP      r0,#0x31              ;271
000008  7811              LDRB     r1,[r2,#0]            ;274
00000a  d012              BEQ      |L15.50|
00000c  2832              CMP      r0,#0x32              ;271
00000e  d016              BEQ      |L15.62|
000010  285a              CMP      r0,#0x5a              ;271
000012  d001              BEQ      |L15.24|
000014  287a              CMP      r0,#0x7a              ;271
000016  d11f              BNE      |L15.88|
                  |L15.24|
000018  f3bf8f4f          DSB                            ;271
00001c  4911              LDR      r1,|L15.100|
00001e  6808              LDR      r0,[r1,#0]            ;271
000020  4a11              LDR      r2,|L15.104|
000022  f40060e0          AND      r0,r0,#0x700          ;271
000026  4310              ORRS     r0,r0,r2              ;271
000028  6008              STR      r0,[r1,#0]            ;271
00002a  f3bf8f4f          DSB                            ;271
                  |L15.46|
00002e  bf00              NOP                            ;271
000030  e7fd              B        |L15.46|
                  |L15.50|
000032  295a              CMP      r1,#0x5a              ;274
000034  d901              BLS      |L15.58|
000036  215a              MOVS     r1,#0x5a              ;274
000038  e006              B        |L15.72|
                  |L15.58|
00003a  1c49              ADDS     r1,r1,#1              ;274
00003c  e004              B        |L15.72|
                  |L15.62|
;;;276    			break;
;;;277    
;;;278    		case '2':
;;;279    			pwm_duty = ( pwm_duty < 10) ? (10) : (pwm_duty-1) ;		
00003e  290a              CMP      r1,#0xa
000040  d201              BCS      |L15.70|
000042  210a              MOVS     r1,#0xa
000044  e000              B        |L15.72|
                  |L15.70|
000046  1e49              SUBS     r1,r1,#1
                  |L15.72|
000048  b2cb              UXTB     r3,r1
00004a  7013              STRB     r3,[r2,#0]
;;;280        		EPWM_ConfigOutputChannel(EPWM0, 2, pwm_freq, pwm_duty);			
00004c  4620              MOV      r0,r4
00004e  220f              MOVS     r2,#0xf
000050  bc30              POP      {r4,r5}
000052  2102              MOVS     r1,#2
000054  f7ffbffe          B.W      EPWM_ConfigOutputChannel
                  |L15.88|
;;;281    			break;
;;;282    
;;;283    		case 'Z':
;;;284    		case 'z':
;;;285    			NVIC_SystemReset();
;;;286    			break;
;;;287    
;;;288    		default :
;;;289    			break;
;;;290    	}	
;;;291    }
000058  bc30              POP      {r4,r5}
00005a  4770              BX       lr
;;;292    
                          ENDP

                  |L15.92|
                          DCD      0x40058000
                  |L15.96|
                          DCD      ||area_number.23||
                  |L15.100|
                          DCD      0xe000ed0c
                  |L15.104|
                          DCD      0x05fa0004

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;459    
;;;460    int main()
000000  f7fffffe          BL       SYS_Init
;;;461    {	
;;;462        SYS_Init();
;;;463    
;;;464        UART0_Init();	
000004  f7fffffe          BL       UART0_Init
;;;465    	TIMER1_Init();
000008  f7fffffe          BL       TIMER1_Init
;;;466    
;;;467        EPWM_Init();
00000c  f7fffffe          BL       EPWM_Init
;;;468    	
;;;469    	EPWM_CAP_PDMA_Init();
000010  f7fffffe          BL       EPWM_CAP_PDMA_Init
;;;470    	EPWM_CAP_Init();
000014  f7fffffe          BL       EPWM_CAP_Init
                  |L16.24|
;;;471    
;;;472    	/*
;;;473    		output : EPWM0_CH2 (PA.3)
;;;474    		capture : EPWM1_CH5 (PB.6)
;;;475    	*/
;;;476    
;;;477    
;;;478        /* Got no where to go, just loop forever */
;;;479        while(1)
;;;480        {
;;;481    //		EPWM_CAP_PDMA_Init();
;;;482    //		EPWM_CAP_Init();
;;;483    	
;;;484    		CalculationPolling();
000018  f7fffffe          BL       CalculationPolling
00001c  e7fc              B        |L16.24|
;;;485    
;;;486    //		EPWM_CAP_Disable();
;;;487        }
;;;488    
;;;489    }
;;;490    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  uart0Dev
                          %        260

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  pwm_freq
                          DCD      0x0000000f

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  52697369          DCB      "Rising=%5d,Falling=%5d,High=%5d,Low=%5d,Total=%5d,Freq="
000004  6e673d25
000008  35642c46
00000c  616c6c69
000010  6e673d25
000014  35642c48
000018  6967683d
00001c  2535642c
000020  4c6f773d
000024  2535642c
000028  546f7461
00002c  6c3d2535
000030  642c4672
000034  65713d  
000037  2535642c          DCB      "%5d,Duty=%3d.\r\n",0
00003b  44757479
00003f  3d253364
000043  2e0d0a00

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
                          DCD      0x00000000

                          AREA ||area_number.23||, DATA, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.data||
                  pwm_duty
000000  1e00              DCB      0x1e,0x00
                  capt_psc
000002  0000              DCW      0x0000
                  ||CNT||
000004  0000              DCW      0x0000
                  u16UART_RX_Buffer_Index
000006  0000              DCW      0x0000
                  g_u32CH0TestOver
                          DCD      0x00000000
                  capt_div_freq
                          DCD      0x00000000
                  g_u32Count
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
